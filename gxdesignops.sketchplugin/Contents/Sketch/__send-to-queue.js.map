{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/@skpm/child_process/index.js","webpack://exports/./node_modules/@skpm/child_process/lib/exec.js","webpack://exports/./node_modules/@skpm/child_process/lib/execFile.js","webpack://exports/./node_modules/@skpm/child_process/lib/execFileSync.js","webpack://exports/./node_modules/@skpm/child_process/lib/execSync.js","webpack://exports/./node_modules/@skpm/child_process/lib/handleData.js","webpack://exports/./node_modules/@skpm/child_process/lib/normalizeSpawnArguments.js","webpack://exports/./node_modules/@skpm/child_process/lib/spawn.js","webpack://exports/./node_modules/@skpm/child_process/lib/spawnSync.js","webpack://exports/./src/send-to-queue.js","webpack://exports/external \"buffer\"","webpack://exports/external \"events\"","webpack://exports/external \"sketch\"","webpack://exports/external \"sketch/ui\"","webpack://exports/external \"stream\""],"names":["UI","require","exportLayer","layer","path","options","output","exportFormats","length","name","console","log","sketch","export","layers","child","doc","getSelectedDocument","queuePath","imageFolder","decodeURIComponent","replace","pages","forEach","page","spawn","spawnSync","shell","status","Error","stderr","message"],"mappings":";;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,sBAAsB,mBAAO,CAAC,kEAAY;AAC1C,0BAA0B,mBAAO,CAAC,0EAAgB;AAClD,uBAAuB,mBAAO,CAAC,oEAAa;AAC5C,2BAA2B,mBAAO,CAAC,4EAAiB;AACpD,8BAA8B,mBAAO,CAAC,kFAAoB;AAC1D,0BAA0B,mBAAO,CAAC,0EAAgB;;;;;;;;;;;;ACLlD,eAAe,mBAAO,CAAC,sEAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA,YAAY,mBAAO,CAAC,gEAAS;AAC7B,iBAAiB,mBAAO,CAAC,0EAAc;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;AC1KA,gBAAgB,mBAAO,CAAC,wEAAa;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yDAAyD;AACzD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC5DA,mBAAmB,mBAAO,CAAC,8EAAgB;;AAE3C;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AChBA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpHA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,gBAAgB,mBAAO,CAAC,wEAAa;AACrC,8BAA8B,mBAAO,CAAC,oGAA2B;;AAEjE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;AC1OA;AACA,iBAAiB,mBAAO,CAAC,0EAAc;AACvC,8BAA8B,mBAAO,CAAC,oGAA2B;;AAEjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA,IAAIA,EAAE,GAAGC,mBAAO,CAAC,4BAAD,CAAhB;;AAEA,IAAIC,WAAW,GAAG,SAAdA,WAAc,CAAUC,KAAV,EAAkBC,IAAlB,EAClB;AACE,MAAMC,OAAO,GAAG;AAAEC,UAAM,EAAEF;AAAV,GAAhB;;AAEA,MAAID,KAAK,CAACI,aAAN,IAAuBJ,KAAK,CAACI,aAAN,CAAoBC,MAApB,GAA6B,CAAxD,EACC;AACG,QAAIL,KAAK,CAACM,IAAV,EACEC,OAAO,CAACC,GAAR,CAAY,eAAeR,KAAK,CAACM,IAAjC;AACFG,iDAAM,CAACC,MAAP,CAAcV,KAAd,EAAqBE,OAArB;AACF;;AACF,MAAIF,KAAK,CAACW,MAAV,EACA;AACE,SAAK,IAAIC,KAAT,IAAkBZ,KAAK,CAACW,MAAxB,EACA;AACEJ,aAAO,CAACC,GAAR,CAAYI,KAAZ;AACAb,iBAAW,CAACa,KAAD,CAAX;AACD;AACF;AACF,CAlBD;;AAoBe,2EAAW;AAEvB;;;;;;;;;;;;;;AAcD,MAAMC,GAAG,GAAGJ,6CAAM,CAACK,mBAAP,EAAZ;AACA,MAAMC,SAAS,GAAG,gCAAlB;AAEA,MAAIC,WAAW,GAAID,SAAS,GAAGE,kBAAkB,CAACJ,GAAG,CAACZ,IAAL,CAAlB,CAA6BiB,OAA7B,CAAqC,WAArC,EAAkD,EAAlD,EAAsDA,OAAtD,CAA8D,SAA9D,EAAyE,EAAzE,CAA/B;AACAX,SAAO,CAACC,GAAR,CAAY,gBAAgBQ,WAA5B;AACAH,KAAG,CAACM,KAAJ,CAAUC,OAAV,CAAmB,UAAAC,IAAI,EACrB;AACEA,QAAI,CAACV,MAAL,CAAYS,OAAZ,CAAqB,UAAApB,KAAK,EACxB;AACED,iBAAW,CAACC,KAAD,EAAQgB,WAAR,CAAX;AACD,KAHH;AAID,GANH;AAUD,MAAMM,KAAK,GAAGC,qEAAS,CAAC,IAAD,EAAO,CAC5B,MAAMN,kBAAkB,CAACJ,GAAG,CAACZ,IAAL,CAAxB,GAAqC,GADT,EAE5Bc,SAF4B,CAAP,EAGpB;AAAES,SAAK,EAAE;AAAT,GAHoB,CAAvB;;AAOA,MAAIF,KAAK,CAACG,MAAN,GAAe,CAAnB,EACA;AACElB,WAAO,CAACC,GAAR,CAAYkB,KAAK,CAACJ,KAAK,CAACK,MAAP,CAAjB;AACAlB,iDAAM,CAACZ,EAAP,CAAU+B,OAAV,CAAkB,uDAAlB;AACA,GAJF,MAMCnB,6CAAM,CAACZ,EAAP,CAAU+B,OAAV,CAAkB,iCAAlB;AAGD,C;;;;;;;;;;;ACxED,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,mC","file":"__send-to-queue.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/send-to-queue.js\");\n","module.exports.exec = require('./lib/exec')\nmodule.exports.execFile = require('./lib/execFile')\nmodule.exports.spawn = require('./lib/spawn')\nmodule.exports.spawnSync = require('./lib/spawnSync')\nmodule.exports.execFileSync = require('./lib/execFileSync')\nmodule.exports.execSync = require('./lib/execSync')\n","var execFile = require('./execFile')\n\nfunction normalizeExecArgs(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = undefined\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options)\n  options.shell = typeof options.shell === 'string' ? options.shell : true\n\n  return {\n    file: command,\n    options: options,\n    callback: callback\n  }\n}\n\nmodule.exports = function exec(command, options, callback) {\n  var opts = normalizeExecArgs(command, options, callback)\n  return execFile(opts.file, opts.options, opts.callback)\n}\n","/* globals NSMutableData, NSData */\nvar spawn = require('./spawn')\nvar handleData = require('./handleData')\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.timeout')\n  }\n}\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.maxBuffer')\n  }\n}\n\nfunction concatData(prev, data) {\n  prev.appendData(data)\n  return prev\n}\n\nmodule.exports = function execFile(file, args, options, callback) {\n  var defaultOptions = {\n    encoding: 'utf8',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: undefined,\n    env: undefined,\n    shell: false\n  }\n\n  if (typeof args === 'function') {\n    // function (file, callback)\n    callback = args\n    args = []\n    options = defaultOptions\n  } else if (typeof args === 'object' && !Array.isArray(args)) {\n    // function (file, options, callback)\n    callback = options\n    options = Object.assign(defaultOptions, args)\n    args = []\n  } else {\n    // function (file, args, options, callback)\n    options = Object.assign(defaultOptions, options)\n  }\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout)\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer)\n\n  var child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell\n  })\n\n  var encoding = options.encoding\n  var _stdout = []\n  var _stderr = []\n\n  var stdoutLen = 0\n  var stderrLen = 0\n  var killed = false\n  var exited = false\n  var timeoutId\n\n  var ex = null\n\n  var cmd = file\n\n  function exithandler(code, signal) {\n    if (exited) return\n    exited = true\n\n    if (timeoutId) {\n      clearTimeout(timeoutId)\n      timeoutId = null\n    }\n\n    if (!callback) return\n\n    // merge chunks\n    var stdout = handleData(\n      NSData.dataWithData(_stdout.reduce(concatData, NSMutableData.data())),\n      encoding\n    )\n    var stderr = handleData(\n      NSData.dataWithData(_stderr.reduce(concatData, NSMutableData.data())),\n      encoding\n    )\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr)\n      return\n    }\n\n    if (args.length !== 0) {\n      cmd += ' ' + args.join(' ')\n    }\n\n    if (!ex) {\n      ex = new Error('Command failed: ' + cmd + '\\n' + stderr)\n      ex.killed = child.killed || killed\n      ex.code = code\n      ex.signal = signal\n    }\n\n    ex.cmd = cmd\n    callback(ex, stdout, stderr)\n  }\n\n  function errorhandler(e) {\n    ex = e\n\n    exithandler()\n  }\n\n  function kill() {\n    killed = true\n    try {\n      child.kill(options.killSignal)\n    } catch (e) {\n      ex = e\n      exithandler()\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill()\n      timeoutId = null\n    }, options.timeout)\n  }\n\n  if (child.stdout) {\n    child.stdout.setEncoding('NSData')\n    child.stdout.on('data', function onChildStdout(chunk) {\n      stdoutLen += chunk.length()\n      if (stdoutLen > options.maxBuffer) {\n        ex = new Error('ERR_CHILD_PROCESS_STDIO_MAXBUFFER stdout')\n        kill()\n      } else {\n        _stdout.push(chunk)\n      }\n    })\n  }\n\n  if (child.stderr) {\n    child.stderr.setEncoding('NSData')\n    child.stderr.on('data', function onChildStderr(chunk) {\n      stderrLen += chunk.length()\n\n      if (stderrLen > options.maxBuffer) {\n        ex = new Error('ERR_CHILD_PROCESS_STDIO_MAXBUFFER stderr')\n        kill()\n      } else {\n        _stderr.push(chunk)\n      }\n    })\n  }\n\n  child.addListener('close', exithandler)\n  child.addListener('error', errorhandler)\n\n  return child\n}\n","var spawnSync = require('./spawnSync')\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.timeout')\n  }\n}\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.maxBuffer')\n  }\n}\n\nmodule.exports = function execFileSync(file, args, options) {\n  var defaultOptions = {\n    encoding: 'buffer',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: null,\n    env: null,\n    shell: false\n  }\n\n  if (typeof args === 'object' && !Array.isArray(args)) {\n    // function (file, options)\n    options = Object.assign(defaultOptions, args)\n    args = []\n  } else {\n    // function (file)\n    options = Object.assign(defaultOptions, options || {})\n  }\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout)\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer)\n\n  var child = spawnSync(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell,\n    encoding: options.encoding,\n    stdio: ['pipe', 'pipe', 'inherit']\n  })\n\n  if (child.status !== 0) {\n    var error = new Error('Failed to run: ' + String(child.stderr))\n    error.pid = child.pid\n    error.status = child.status\n    error.stdout = child.stdout\n    error.stderr = child.stderr\n    throw error\n  }\n\n  return child.stdout\n}\n","var execFileSync = require('./execFileSync')\n\nfunction normalizeExecArgs(command, options) {\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options)\n  options.shell = typeof options.shell === 'string' ? options.shell : true\n\n  return {\n    file: command,\n    options: options\n  }\n}\n\nmodule.exports = function execSync(command, options) {\n  var opts = normalizeExecArgs(command, options)\n  return execFileSync(opts.file, opts.options)\n}\n","var Buffer = require('buffer').Buffer\n\nfunction handleBuffer(buffer, encoding) {\n  if (encoding === 'buffer') {\n    return buffer\n  }\n  if (encoding === 'NSData') {\n    return buffer.toNSData()\n  }\n  return buffer.toString(encoding)\n}\n\nmodule.exports = function handleData(data, encoding) {\n  var buffer = Buffer.from(data)\n\n  return handleBuffer(buffer, encoding)\n}\n","module.exports = function normalizeSpawnArguments(file, args, options) {\n  if (typeof file !== 'string' || file.length === 0) {\n    throw new Error('ERR_INVALID_ARG_TYPE')\n  }\n\n  if (Array.isArray(args)) {\n    args = args.slice(0)\n  } else if (\n    args !== undefined &&\n    (args === null || typeof args !== 'object')\n  ) {\n    throw new Error('ERR_INVALID_ARG_TYPE args')\n  } else {\n    options = args\n    args = []\n  }\n\n  if (options === undefined) {\n    options = {}\n  } else if (options === null || typeof options !== 'object') {\n    throw new Error('ERR_INVALID_ARG_TYPE options')\n  }\n\n  // Validate the cwd, if present.\n  if (options.cwd != null && typeof options.cwd !== 'string') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.cwd')\n  }\n\n  // Validate detached, if present.\n  if (options.detached != null && typeof options.detached !== 'boolean') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.detached')\n  }\n\n  // Validate the uid, if present.\n  if (options.uid != null && !Number.isInteger(options.uid)) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.uid')\n  }\n\n  // Validate the gid, if present.\n  if (options.gid != null && !Number.isInteger(options.gid)) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.gid')\n  }\n\n  // Validate the shell, if present.\n  if (\n    options.shell != null &&\n    typeof options.shell !== 'boolean' &&\n    typeof options.shell !== 'string'\n  ) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.shell')\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null && typeof options.argv0 !== 'string') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.argv0')\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options)\n\n  if (options.shell) {\n    var command = [file].concat(args).join(' ')\n\n    if (typeof options.shell === 'string') {\n      file = options.shell\n    } else {\n      file = '/bin/bash'\n    }\n    args = ['-l', '-c', command]\n  }\n\n  if (typeof options.argv0 === 'string') {\n    args.unshift(options.argv0)\n  }\n\n  var stdio = ['pipe', 'pipe', 'pipe']\n\n  if (typeof options.stdio === 'string') {\n    if (options.stdio === 'inherit') {\n      stdio = [0, 1, 2]\n    } else {\n      stdio = [options.stdio, options.stdio, options.stdio]\n    }\n  } else if (Array.isArray(options.stdio)) {\n    if (options.stdio[0] || options.stdio[0] === 0) {\n      if (options.stdio[0] === 'inherit') {\n        stdio[0] = 0\n      } else {\n        stdio[0] = options.stdio[0]\n      }\n    }\n    if (options.stdio[1] || options.stdio[1] === 0) {\n      if (options.stdio[1] === 'inherit') {\n        stdio[1] = 1\n      } else {\n        stdio[1] = options.stdio[1]\n      }\n    }\n    if (options.stdio[2] || options.stdio[2] === 0) {\n      if (options.stdio[2] === 'inherit') {\n        stdio[2] = 2\n      } else {\n        stdio[2] = options.stdio[2]\n      }\n    }\n  }\n\n  var env = options.env\n\n  return {\n    file: file,\n    args: args,\n    options: options,\n    envPairs: env,\n    stdio: stdio\n  }\n}\n","/* globals NSPipe, NSTask, NSArray, NSString, coscript, __mocha__ */\nvar Buffer = require('buffer').Buffer\nvar EventEmitter = require('events')\nvar Readable = require('stream').Readable\nvar Writable = require('stream').Writable\n\nvar spawnSync = require('./spawnSync')\nvar normalizeSpawnArguments = require('./normalizeSpawnArguments')\n\nmodule.exports = function spawn(_command, _args, _options) {\n  var opts = normalizeSpawnArguments(_command, _args, _options)\n\n  var result = new EventEmitter()\n\n  if (opts.file[0] !== '.' && opts.file[0] !== '/' && opts.file[0] !== '~') {\n    // means that someone refered to an executable that might be in the path, let's find it\n    var whichChild = spawnSync(\n      '/bin/bash',\n      ['-l', '-c', 'which ' + opts.file],\n      { encoding: 'utf8' }\n    )\n    var resolvedCommand = String(whichChild.stdout || '').trim()\n    if (whichChild.err || !resolvedCommand.length) {\n      result.stderr = new EventEmitter()\n      result.stdout = new EventEmitter()\n\n      result.pid = '-1'\n\n      result.stderr.setEncoding = function setEncoding(encoding) {\n        result.stderr.encoding = encoding\n      }\n      result.stdout.setEncoding = function setEncoding(encoding) {\n        result.stdout.encoding = encoding\n      }\n      if (!resolvedCommand.length) {\n        result.emit('error', new Error(String(opts.file) + ' ENOENT'))\n      } else {\n        result.emit('error', whichChild.err)\n      }\n      return result\n    }\n    return spawn(resolvedCommand, _args, _options)\n  }\n\n  var options = opts.options\n\n  result.killed = false\n\n  var fiber = coscript.createFiber()\n\n  var task\n  var signal = null\n\n  var readingStderr = false\n  var readingStdout = false\n\n  result.stderr = new Readable({\n    read: function read() {\n      readingStderr = true\n    }\n  })\n  result.stdout = new Readable({\n    read: function read() {\n      readingStdout = true\n    }\n  })\n\n  function onStdout(data) {\n    if (data && data.length() && readingStdout) {\n      if (!result.stdout.push(Buffer.from(data))) {\n        readingStdout = false\n        task\n          .standardOutput()\n          .fileHandleForReading()\n          .setReadabilityHandler(null)\n      }\n    }\n  }\n  function onStderr(data) {\n    if (data && data.length() && readingStderr) {\n      if (!result.stderr.push(Buffer.from(data))) {\n        readingStderr = false\n        task\n          .standardError()\n          .fileHandleForReading()\n          .setReadabilityHandler(null)\n      }\n    }\n  }\n\n  result.sdtin = new Writable({\n    write: function write(chunk, encoding, callback) {\n      task\n        .standardInput()\n        .fileHandleForWriting()\n        .writeData(chunk.toNSData())\n      callback()\n    },\n    final: function finish(callback) {\n      task\n        .standardInput()\n        .fileHandleForWriting()\n        .closeFile()\n      callback()\n    }\n  })\n\n  result.sdtio = [result.sdtin, result.sdtout, result.sdterr]\n\n  try {\n    task = NSTask.alloc().init()\n\n    var inPipe = NSPipe.pipe()\n    var pipe = NSPipe.pipe()\n    var errPipe = NSPipe.pipe()\n\n    task.setStandardInput(inPipe)\n    task.setStandardOutput(pipe)\n    task.setStandardError(errPipe)\n\n    task\n      .standardOutput()\n      .fileHandleForReading()\n      .setReadabilityHandler(\n        __mocha__.createBlock_function(\n          'v16@?0@\"NSFileHandle\"8',\n          function readStdOut(fileHandle) {\n            try {\n              onStdout(fileHandle.availableData())\n            } catch (err) {\n              if (\n                typeof process !== 'undefined' &&\n                process.listenerCount &&\n                process.listenerCount('uncaughtException')\n              ) {\n                process.emit('uncaughtException', err, 'uncaughtException')\n              } else {\n                console.error(err)\n              }\n            }\n          }\n        )\n      )\n    task\n      .standardError()\n      .fileHandleForReading()\n      .setReadabilityHandler(\n        __mocha__.createBlock_function(\n          'v16@?0@\"NSFileHandle\"8',\n          function readStdOut(fileHandle) {\n            try {\n              onStderr(fileHandle.availableData())\n            } catch (err) {\n              if (\n                typeof process !== 'undefined' &&\n                process.listenerCount &&\n                process.listenerCount('uncaughtException')\n              ) {\n                process.emit('uncaughtException', err, 'uncaughtException')\n              } else {\n                console.error(err)\n              }\n            }\n          }\n        )\n      )\n\n    task.setLaunchPath(\n      NSString.stringWithString(opts.file).stringByExpandingTildeInPath()\n    )\n    task.arguments = NSArray.arrayWithArray(opts.args || [])\n    if (opts.envPairs) {\n      task.environment = opts.envPairs\n    }\n    if (options.cwd) {\n      task.setCurrentDirectoryPath(\n        NSString.stringWithString(options.cwd).stringByExpandingTildeInPath()\n      )\n    }\n\n    task.setTerminationHandler(\n      __mocha__.createBlock_function(\n        'v16@?0@\"NSTask\"8',\n        function handleTermination(_task) {\n          try {\n            _task\n              .standardError()\n              .fileHandleForReading()\n              .setReadabilityHandler(null)\n            _task\n              .standardOutput()\n              .fileHandleForReading()\n              .setReadabilityHandler(null)\n            result.stderr.emit('close')\n            result.stdout.emit('close')\n\n            result.killed = true\n\n            result.emit('close', Number(_task.terminationStatus()), signal)\n          } catch (err) {\n            if (\n              typeof process !== 'undefined' &&\n              process.listenerCount &&\n              process.listenerCount('uncaughtException')\n            ) {\n              process.emit('uncaughtException', err, 'uncaughtException')\n            } else {\n              console.error(err)\n            }\n          }\n          fiber.cleanup()\n        }\n      )\n    )\n\n    task.launch()\n  } catch (err) {\n    fiber.cleanup()\n    setImmediate(function() {\n      result.emit('error', err)\n    })\n    return result\n  }\n\n  result.kill = function kill(_signal) {\n    if (!result.killed) {\n      signal = _signal\n      task.terminate()\n    }\n  }\n\n  result.pid = String(task.processIdentifier())\n\n  return result\n}\n","/* globals NSPipe, NSTask, NSArray, NSString */\nvar handleData = require('./handleData')\nvar normalizeSpawnArguments = require('./normalizeSpawnArguments')\n\nfunction spawnSync(_command, _args, _options) {\n  var opts = normalizeSpawnArguments(_command, _args, _options)\n\n  if (opts.file[0] !== '.' && opts.file[0] !== '/' && opts.file[0] !== '~') {\n    // means that someone refered to an executable that might be in the path, let's find it\n    var whichChild = spawnSync(\n      '/bin/bash',\n      ['-l', '-c', 'which ' + opts.file],\n      { encoding: 'utf8' }\n    )\n    if (whichChild.err) {\n      return whichChild\n    }\n    var resolvedCommand = String(whichChild.stdout).trim()\n    if (!resolvedCommand.length) {\n      return {\n        err: new Error(String(opts.file) + ' ENOENT')\n      }\n    }\n    return spawnSync(resolvedCommand, _args, _options)\n  }\n\n  var options = opts.options\n\n  var pipe = NSPipe.pipe()\n  var errPipe = NSPipe.pipe()\n\n  try {\n    var task = NSTask.alloc().init()\n    task.setLaunchPath(\n      NSString.stringWithString(opts.file).stringByExpandingTildeInPath()\n    )\n    task.arguments = NSArray.arrayWithArray(opts.args || [])\n    if (opts.envPairs) {\n      task.environment = opts.envPairs\n    }\n\n    if (options.cwd) {\n      task.setCurrentDirectoryPath(\n        NSString.stringWithString(options.cwd).stringByExpandingTildeInPath()\n      )\n    }\n\n    task.setStandardOutput(pipe)\n    task.setStandardError(errPipe)\n\n    task.launch()\n    task.waitUntilExit()\n\n    var stdoutIgnored = false\n    var stderrIgnored = false\n\n    var data\n    var stdoutValue\n    var stderrValue\n\n    if (opts.stdio[1] === 'ignored') {\n      stdoutIgnored = true\n    } else if (opts.stdio[1] === 1) {\n      data = pipe.fileHandleForReading().readDataToEndOfFile()\n      stdoutValue = handleData(data, options.encoding || 'buffer')\n      console.log(stdoutValue)\n    } else if (opts.stdio[1] === 2) {\n      data = pipe.fileHandleForReading().readDataToEndOfFile()\n      stdoutValue = handleData(data, options.encoding || 'buffer')\n      console.error(stdoutValue)\n    }\n\n    if (opts.stdio[2] === 'ignored') {\n      stderrIgnored = true\n    } else if (opts.stdio[2] === 1) {\n      data = errPipe.fileHandleForReading().readDataToEndOfFile()\n      stderrValue = handleData(data, options.encoding || 'buffer')\n      console.log(stderrValue)\n    } else if (opts.stdio[2] === 2) {\n      data = errPipe.fileHandleForReading().readDataToEndOfFile()\n      stderrValue = handleData(data, options.encoding || 'buffer')\n      console.error(stderrValue)\n    }\n\n    return {\n      pid: String(task.processIdentifier()),\n      status: Number(task.terminationStatus()),\n      get stdout() {\n        if (stdoutIgnored) {\n          return null\n        }\n        if (stdoutValue) {\n          return stdoutValue\n        }\n        data = pipe.fileHandleForReading().readDataToEndOfFile()\n        return handleData(data, options.encoding || 'buffer')\n      },\n      get stderr() {\n        if (stderrIgnored) {\n          return null\n        }\n        if (stderrValue) {\n          return stdoutValue\n        }\n        data = errPipe.fileHandleForReading().readDataToEndOfFile()\n        return handleData(data, options.encoding || 'buffer')\n      }\n    }\n  } catch (err) {\n    return {\n      err: err\n    }\n  }\n}\n\nmodule.exports = spawnSync\n","import sketch from 'sketch';\nimport { spawnSync } from '@skpm/child_process';\n\nvar UI = require(\"sketch/ui\");\n\nvar exportLayer = function( layer , path)\n{\n  const options = { output: path};\n  \n  if (layer.exportFormats && layer.exportFormats.length > 0)\n   {\n      if (layer.name)\n        console.log(\"Exporting \" + layer.name);\n      sketch.export(layer, options);\n   }      \n  if (layer.layers)\n  {\n    for (var child in layer.layers)\n    {\n      console.log(child);\n      exportLayer(child);\n    }\n  }\n}\n\nexport default function() {\n\n   /*\n  let payload = {\n    headers: {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json'\n    },\n    method:'POST',\n    body: {\n      \"FileName\": \"TestFile2\",\n      \"FileContent\" : \"Hola Mundo sketch\"\n    }\n  };\n  fetch('https://apps5.genexus.com/Idd368f10b0d2207f732507442d8a165ef/rest/SketchFiles/TestFile2', payload);\n*/\n  const doc = sketch.getSelectedDocument()\n  const queuePath = '/Volumes/cable/DesignOpsQueue/'\n\n  var imageFolder =  queuePath + decodeURIComponent(doc.path).replace(/^.*[\\\\\\/]/, '').replace(\".sketch\", \"\");\n  console.log(\"Images to :\" + imageFolder)\n  doc.pages.forEach( page =>\n    {\n      page.layers.forEach( layer =>\n        {\n          exportLayer(layer, imageFolder);\n        })\n    });\n  \n\n  \n const spawn = spawnSync('cp', [\n   \"'\" + decodeURIComponent(doc.path) + \"'\",\n   queuePath\n ], { shell: true });\n\n  \n  \n if (spawn.status > 0)\n {\n   console.log(Error(spawn.stderr));\n   sketch.UI.message(\"😔 Some error occurs, see console for further details\");\n  }\n else\n  sketch.UI.message(\"Copied to Design Ops Queue ! 💚\")\n  \n\n}","module.exports = require(\"buffer\");","module.exports = require(\"events\");","module.exports = require(\"sketch\");","module.exports = require(\"sketch/ui\");","module.exports = require(\"stream\");"],"sourceRoot":""}